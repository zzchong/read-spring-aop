# spring—aop的基础
按照惯例，在读源码前，首先需要了解一下框架的名词定义点。名词定义点能让我们快速的捋清楚框架的设计思路。
## 名词定义点
1. Pointcut：切点 ，匹配进行切面行为的地方（通过classFilter匹配或者MethodMatcher匹配）
3. Advice：通知，切面的行为。
2. Advisor：切面，切面由Advice和PointCut构成
  
 由上面几个名词定义点可知，aop设计思路是通过*切点PointCut*匹配需要增强的地方（类或者方法），然后通过*通知Advice*实现具体的增强行为。
 了解了设计思路，接下来看看源码是怎么设计的。
 ## Pointcut
 PointCut的实现依赖于ClassFilter和MethodMatcher。
 先看PointCut的继承关系：  
 
 ![说的是](https://raw.githubusercontent.com/zzchong/read-spring-aop/master/image/PointCut.png)
 
 从上面的继承图可以看出，PointCut分为：  
 1. String表达式切点（ExpressionPointcut）：它是通过AspectJ来实现解析的（AspectJExpressionPointcut）。
 2. 静态方法切点（StaticMethodMatcherPointcut）：不在运行时检测，默认匹配所有类，方法匹配规则按照子类实现来决定。默认实现有两个，NameMatchMethodPointcut按照名称匹配，JdkRegexpMethodPointcut按照正则表达式来匹配。
 3. 动态方法切点（DynamicMethodMatcherPointcut）：在运行时检测，根据运行时方法参数进行实时匹配。
 4. 注解切点（AnnotationMatchingPointcut）：这个非常常用。类和方法匹配分别在AnnotationClassFilter AnnotationMethodMatcher中实现
 5. 复合切点（ComposiblePointcut）：通过多个classFilter和methodMatcher的或与操作，来决定最终的匹配PointCut。
 6. 控制流程切点（ControlFlowPointcut）：匹配特定调用栈的methodName，即只有特定调用栈才能够匹配成功。（简单来说就是，比如类A中的一个方法methodA，只有在类B中通过类A调用MethodA才能匹配成功，在类C中通过类A调用MethodA匹配失败，这个类B就是特定调用栈）
 
切入点了解了之后，我们在看看进入切点后的行为的实现，也就是通知。

##Advice
先看一下Advice的继承关系图：
![说的是](https://raw.githubusercontent.com/zzchong/read-spring-aop/master/image/Advice.png)
